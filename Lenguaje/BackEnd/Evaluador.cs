using AnálisisCodigo.Tipado;
namespace AnálisisCodigo
{
    /// <summary>
    /// Evaluate the expressions in the  AST generated by the Parser.
    /// </summary>
    internal sealed class Evaluator
    {
        private readonly ExpresionTipada _root;
        private readonly Dictionary<VariableSymbol, object> _variables;

        public Evaluator(ExpresionTipada root, Dictionary<VariableSymbol, object> variables)
        {
            this._root = root;
            this._variables = variables;
        }
        public object Evaluate()
        {
            return EvaluateExpresion(_root);
        }
        /*
        Evaluate method can be implemented recursively because the way the ast,
        was build it has the operation ordered by priority. 
        */
        private object EvaluateExpresion(ExpresionTipada node)
        {
            if (node is ExpresionLiteralTipada n)
            {
                return n.Value;
            }

            if (node is ExpresionVariableTipada v)
            {
                return _variables[v.VariableSymbol];
            }

            if (node is ExpresionAsignacionTipada r)
            {
                var value = EvaluateExpresion(r.expresiontipada);
                _variables[r.VariableSymbol] = value;
                return value;
            }

            if (node is ExpresionUnariaTipada u)
            {
                var operand = EvaluateExpresion(u.Operand);
                switch (u.OperadorUnarioTipo.Tipo_Operador)
                {
                    case TipoOperadorUnario.Identidad:
                        return (int)operand;
                    case TipoOperadorUnario.Negacion:
                        return -(int)operand;
                    case TipoOperadorUnario.NegacionLogica:
                        return !(bool)operand;
                    default:
                        throw new Exception($"Unexpected unary operator {u.OperadorUnarioTipo}");
                }
            }
            if (node is ExpresionBinariaTipada b)
            {
                var left = EvaluateExpresion(b.Left);
                var right = EvaluateExpresion(b.Right);

                switch (b.OperadorBinario.Tipo_Operador)
                {
                    case TipoOperadorBinario.AdicionBooleanos:
                        return (((bool)left || (bool)right)) && (! (((bool)left && (bool)right)) );
                    case TipoOperadorBinario.MultiplicacionBooleanos:
                        return  (bool)left && (bool)right;   
                    case TipoOperadorBinario.AdicionNumeros:
                        return (int)left + (int)right;
                    case TipoOperadorBinario.Substraccion:
                        return (int)left - (int)right;
                    case TipoOperadorBinario.MultiplicacionNumeros:
                        return (int)left * (int)right;
                    case TipoOperadorBinario.Division:
                        return (int)left / (int)right;
                    case TipoOperadorBinario.LogicalAnd:
                        return (bool)left && (bool)right;
                    case TipoOperadorBinario.LogicalOr:
                        return (bool)left || (bool)right;
                    case TipoOperadorBinario.Igualdad:
                        return Equals(left, right);
                    case TipoOperadorBinario.Diferente:
                        return !Equals(left,  right);
                    default:
                        throw new Exception($"Unexpected binary operator {b.OperadorBinario}");
                }
            }
            throw new Exception($"Unexpected node {node.tipo}");
        }
    }
} 