using AnálisisCodigo.Tipado;
namespace AnálisisCodigo
{
    /// <summary>
    /// Evaluate the expressions in the  AST generated by the Parser.
    /// </summary>
    internal sealed class Evaluator
    {
        private readonly StatementTipado _root;
        private object _lastValue;
        private readonly Dictionary<VariableSymbol, object> _variables;
        public Evaluator(StatementTipado root, Dictionary<VariableSymbol, object> variables)
        {
            this._root = root;
            this._variables = variables;
        }
        public object Evaluate()
        {
            EvaluateStatement(_root);
            return _lastValue;
        }
        /*
        Evaluate method can be implemented recursively because the way the ast,
        was build it has the operation ordered by priority. 
        */

        private void EvaluateStatement(StatementTipado node)
        {
            switch (node.tipo)
            {
                case TipoNodoTipado.BlockStatement:
                    EvaluateBlockStatement((ExpresionBlockTipada)node);
                    break;
                case TipoNodoTipado.ExpresionStatement:
                    EvaluateExpressionStatement((ExpresionStatementTipada)node);
                    break;
                default:
                    throw new Exception($"Unexpected node {node.tipo}");
            }
        }

        private void EvaluateExpressionStatement(ExpresionStatementTipada node)
        {
            _lastValue = EvaluateExpresion(node.Expresion);
        }

        private void EvaluateBlockStatement(ExpresionBlockTipada node)
        {
            foreach (var statement in node.Statements)
            {
                EvaluateStatement(statement);
            }
        }

        private object EvaluateExpresion(ExpresionTipada node)
        {
            switch (node)
            {
                case ExpresionLiteralTipada n:
                    return EvaluateLiteralExpression(n);
                case ExpresionVariableTipada v:
                    return EvaluateVariableExpression(v);
                case ExpresionAsignacionTipada r:
                    return EvaluateAsignacionExpression(r);
                case ExpresionUnariaTipada u:
                    return EvaluateUnaryExpression(u);
                case ExpresionBinariaTipada b:
                    return EvaluateExpresionBinaria(b);
                default:
                    throw new Exception($"Unexpected node {node.tipo}");
            }
        }
        private object EvaluateExpresionBinaria(ExpresionBinariaTipada b)
        {
            var left = EvaluateExpresion(b.Left);
            var right = EvaluateExpresion(b.Right);

            switch (b.OperadorBinario.Tipo_Operador)
            {
                case TipoOperadorBinario.AdicionBooleanos:
                    return (((bool)left || (bool)right)) && (!(((bool)left && (bool)right)));
                case TipoOperadorBinario.MultiplicacionBooleanos:
                    return (bool)left && (bool)right;
                case TipoOperadorBinario.AdicionNumeros:
                    return (int)left + (int)right;
                case TipoOperadorBinario.Substraccion:
                    return (int)left - (int)right;
                case TipoOperadorBinario.MultiplicacionNumeros:
                    return (int)left * (int)right;
                case TipoOperadorBinario.Division:
                    return (int)left / (int)right;
                case TipoOperadorBinario.LogicalAnd:
                    return (bool)left && (bool)right;
                case TipoOperadorBinario.LogicalOr:
                    return (bool)left || (bool)right;
                case TipoOperadorBinario.Igualdad:
                    return Equals(left, right);
                case TipoOperadorBinario.Diferente:
                    return !Equals(left, right);
                default:
                    throw new Exception($"Unexpected binary operator {b.OperadorBinario}");
            }
        }

        private object EvaluateAsignacionExpression(ExpresionAsignacionTipada r)
        {
            var value = EvaluateExpresion(r.expresiontipada);
            _variables[r.VariableSymbol] = value;
            return value;
        }

        private object EvaluateUnaryExpression(ExpresionUnariaTipada u)
        {
            var operand = EvaluateExpresion(u.Operand);
            switch (u.OperadorUnarioTipo.Tipo_Operador)
            {
                case TipoOperadorUnario.Identidad:
                    return (int)operand;
                case TipoOperadorUnario.Negacion:
                    return -(int)operand;
                case TipoOperadorUnario.NegacionLogica:
                    return !(bool)operand;
                default:
                    throw new Exception($"Unexpected unary operator {u.OperadorUnarioTipo}");
            }
        }

        private object EvaluateVariableExpression(ExpresionVariableTipada v)
        {
            return _variables[v.VariableSymbol];
        }

        private object EvaluateLiteralExpression(ExpresionLiteralTipada n)
        {
            return n.Value;
        }
    }
}